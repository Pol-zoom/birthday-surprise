<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>С Днём Рождения, Алёна!</title>
<style>
  :root{
    --bg:#0a0210;
    --neon:#ff00ff;
    --neon-2:#8a2be2;
    --neon-pink:#ff69b4;
    --neon-cyan:#8be7ff;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    min-height:100vh;
    background:var(--bg);
    font-family:"Courier New", monospace;
    color:var(--neon);
    overflow:hidden;
    display:flex;
    justify-content:center;
    align-items:center;
    cursor:pointer;
  }

  /* Canvas - фон и частицы*/
  canvas{ position:fixed; top:0; left:0; width:100%; height:100%; z-index:0; display:block; }

  /* Центральный экран */
  .screen{
    position:relative;
    z-index:3;
    width:84%;
    max-width:820px;
    min-width:320px;
    padding:24px;
    background:rgba(18,4,30,0.82);
    border-radius:14px;
    border:2px solid var(--neon);
    box-shadow:0 0 22px var(--neon),0 0 44px var(--neon-2);
    text-align:left;
  }

  #hackText{ min-height:56px; font-size:18px; color:var(--neon); }

  .typing-cursor::after{
    content:"";
    display:inline-block;
    width:2px;
    height:1.05em;
    background:var(--neon);
    margin-left:6px;
    animation:blink 0.8s steps(1) infinite;
    vertical-align:bottom;
  }
  @keyframes blink{ 0%,50%,100%{opacity:1} 25%,75%{opacity:0} }

  .card{
    margin-top:18px;
    padding:14px;
    background:rgba(0,0,0,0.45);
    border-radius:10px;
    border:1px solid rgba(255,0,255,0.12);
    box-shadow:0 0 10px rgba(255,0,255,0.06);
    display:none;
    text-align:left;
  }

  .card p{
    margin:8px 0;
    color:var(--neon);
    font-size:16px;
    line-height:1.25;
    opacity:0; /* появится через JS */
  }

  /* стартовое сообщение */
  #startMessage{
    position:absolute;
    z-index:4;
    top:50%; left:50%;
    transform:translate(-50%,-50%);
    text-align:center;
    color:var(--neon);
    font-size:20px;
    padding:10px 16px;
    border-radius:8px;
    text-shadow:0 0 10px var(--neon);
    pointer-events:none;
  }

  @media (max-width:900px){
    .screen{ width:95%; }
  }
</style>
</head>
<body>

<canvas id="matrixCanvas"></canvas>
<!-- дополнительный canvas для частиц поверх фонового, чтобы проще рендерить -->
<canvas id="particleCanvas" style="z-index:2; position:fixed; top:0; left:0;"></canvas>

<div class="screen" id="screen">
  <div id="hackText" aria-live="polite"></div>
  <div class="card" id="card" aria-hidden="true"></div>
</div>

<div id="startMessage">Нажмите Enter или тапните по экрану, чтобы начать</div>

<script>
/* =========================
   Настройки и константы
   ========================= */
const matrixCanvas = document.getElementById('matrixCanvas');
const matrixCtx = matrixCanvas.getContext('2d');
const particleCanvas = document.getElementById('particleCanvas');
const pctx = particleCanvas.getContext('2d');

let W = matrixCanvas.width = particleCanvas.width = window.innerWidth;
let H = matrixCanvas.height = particleCanvas.height = window.innerHeight;

/* -------- matrix (падающий код) -------- */
let fontSize = Math.max(14, Math.floor(Math.min(W, H) / 48)); // адаптивный размер
let columns = Math.floor(W / fontSize);
let drops = new Array(columns).fill(0);

const chars = '0123456789abcdef<>/{}[]()@#$%^&*-_=+;:,.;:';

/* стиль и плотность фона */
function resetMatrix(){
  W = matrixCanvas.width = particleCanvas.width = window.innerWidth;
  H = matrixCanvas.height = window.innerHeight;
  fontSize = Math.max(14, Math.floor(Math.min(W, H) / 48));
  columns = Math.floor(W / fontSize);
  drops = new Array(columns);
  for(let i=0;i<columns;i++) drops[i] = Math.floor(Math.random()*H/fontSize);
}
resetMatrix();

let matrixTick;
function drawMatrix(){
  // полупрозрачное затемнение — следы
  matrixCtx.fillStyle = 'rgba(2,0,6,0.06)';
  matrixCtx.fillRect(0,0,W,H);

  matrixCtx.font = `${fontSize}px monospace`;

  for(let i=0;i<columns;i++){
    const rand = Math.random();
    // цветовые вариации: чаще фиолет, иногда розовый/синий
    if(rand < 0.82) matrixCtx.fillStyle = '#ff00ff';
    else if(rand < 0.93) matrixCtx.fillStyle = '#ff69b4';
    else matrixCtx.fillStyle = '#8a2be2';
    const ch = chars[Math.floor(Math.random()*chars.length)];
    matrixCtx.fillText(ch, i*fontSize, drops[i]*fontSize);

    if(drops[i]*fontSize > H && Math.random() > 0.975) drops[i]=0;
    drops[i]++;
  }
}

/* ========= particles (взрыв символов) ========= */
const particles = [];

function spawnExplosion(x, y, colorMain='#ff00ff', count=28){
  // x,y в координатах окна (px)
  for(let i=0;i<count;i++){
    const angle = Math.random() * Math.PI * 2;
    const speed = (Math.random()*2.6 + 1.2) * (1 + window.devicePixelRatio*0.2);
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;
    const life = Math.random()*500 + 400; // ms
    const size = Math.random()*6 + 4;
    // цвет: основной или случайные
    const r = Math.random();
    let color = colorMain;
    if(r > 0.85) color = '#ff69b4';
    else if(r > 0.95) color = '#8a2be2';
    particles.push({
      x, y, vx, vy, life, born: performance.now(), size, color, alpha:1,
      char: chars[Math.floor(Math.random()*chars.length)]
    });
  }
}

function updateParticles(now){
  // очистка
  pctx.clearRect(0,0,W,H);
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    const age = now - p.born;
    if(age >= p.life){
      particles.splice(i,1);
      continue;
    }
    // простая физика + затухающая альфа
    const t = age / p.life;
    p.x += p.vx * (1 + 0.02 * (Math.random()-0.5));
    p.y += p.vy * (1 + 0.02 * (Math.random()-0.5));
    p.alpha = 1 - t;
    // рисуем символ или квадратик
    pctx.globalAlpha = p.alpha;
    pctx.fillStyle = p.color;
    pctx.font = `${Math.max(10, Math.floor(p.size))}px monospace`;
    pctx.fillText(p.char, p.x, p.y);
    pctx.globalAlpha = 1;
  }
}

/* ========= хакерская анимация и пожелания ========= */
const hackSteps = [
  "Ищется код...",
  "Код не найден",
  "Идём на крайние меры",
  "Взлом Пентагона...",
  "Странно, в Пентагоне этого кода нет...",
  "Тогда глянем Компьютер креатора данного кода",
  "О! Вот он!"
];

const wishes = [
  "С Днём Рождения, Алёна!",
  "Пусть каждый день будет ярким, как этот неон!",
  "Желаю счастья, радости и вдохновения!",
  "Пусть все мечты сбываются!"
];

const hackTextElem = document.getElementById('hackText');
const card = document.getElementById('card');
const startMessage = document.getElementById('startMessage');

function typeTextToElement(el, text, speed = 60){
  return new Promise(resolve=>{
    el.classList.add('typing-cursor');
    el.textContent = '';
    let i = 0;
    const iv = setInterval(()=>{
      if(i >= text.length){
        clearInterval(iv);
        setTimeout(()=>{ el.classList.remove('typing-cursor'); resolve(); }, 300);
        return;
      }
      el.textContent += text[i];
      i++;
    }, speed);
  });
}

// helper: get center coords of an element for explosion origin
function getElementCenterRect(el){
  const r = el.getBoundingClientRect();
  return {
    x: r.left + r.width / 2,
    y: r.top + r.height / 2
  };
}

async function runHackSequence(){
  for(let i=0;i<hackSteps.length;i++){
    hackTextElem.textContent = '';
    await typeTextToElement(hackTextElem, hackSteps[i], 70);
    await new Promise(r => setTimeout(r, 550));
  }
  // плавно скрываем хакText и показываем карточку
  hackTextElem.style.transition = 'opacity 300ms';
  hackTextElem.style.opacity = '0';
  await new Promise(r => setTimeout(r, 320));
  card.style.display = 'block';
  card.setAttribute('aria-hidden','false');
  await runCardWithExplosions();
}

async function runCardWithExplosions(){
  for(let i=0;i<wishes.length;i++){
    const p = document.createElement('p');
    card.appendChild(p);
    // печатаем в параграф
    await typeTextToElement(p, wishes[i], i===0 ? 100 : 60);
    // запуск вспышки (CSS-перечисление уже даёт flash), а также частиц из центра строки
    p.style.animation = 'none';
    // force reflow so animation can be reapplied if needed
    void p.offsetWidth;
    p.style.animation = 'flash 0.42s forwards';
    // координаты центра параграфа -> spawnExplosion
    const pos = getElementCenterRect(p);
    // немного выше, чтобы частицы взлетали из середины текста
    spawnExplosion(pos.x, pos.y - 6, '#ff00ff', 36);
    // небольшая пауза чтобы успеть прочитать
    await new Promise(r => setTimeout(r, 420));
  }
}

/* ========= animation loop ========= */
let running = false;
function animate(now){
  // матрица рисуется таймером setInterval, частицы в RAF
  updateParticles(now);
  if(running) requestAnimationFrame(animate);
}

/* ========= старт/стоп и события ========= */
function startAll(){
  if(running) return;
  running = true;
  startMessage.style.display = 'none';
  // matrix ticker (use interval for stable speed)
  matrixTick = setInterval(drawMatrix, 35);
  requestAnimationFrame(animate);
  // запускаем анимацию хакерской сцены
  runHackSequence();
  // отключаем слушатели старта
  window.removeEventListener('keydown', onKey);
  window.removeEventListener('touchstart', onTouch);
  window.removeEventListener('click', onClickStart);
}

function onKey(e){
  if(e.key === 'Enter') startAll();
}
function onTouch(){ startAll(); }
function onClickStart(){ startAll(); }

window.addEventListener('keydown', onKey);
window.addEventListener('touchstart', onTouch, {passive:true});
window.addEventListener('click', onClickStart);

window.addEventListener('resize', ()=>{
  resetMatrix();
  // don't clear particles — adjust canvas size
  W = matrixCanvas.width = particleCanvas.width = window.innerWidth;
  H = matrixCanvas.height = window.innerHeight;
});

/* safety: stop matrix when leaving page (optional) */
window.addEventListener('blur', ()=>{ /* optional pause */ });

/* ========= CSS animation 'flash' defined dynamically (for compatibility) ========= */
// append keyframes for flash so it's present
(function addFlashKeyframes(){
  const style = document.createElement('style');
  style.innerHTML = `
  @keyframes flash {
    0% { opacity: 0; text-shadow:0 0 22px var(--neon),0 0 44px var(--neon-pink);}
    35% { opacity: 1; text-shadow:0 0 40px var(--neon),0 0 60px var(--neon-pink);}
    100% { opacity: 1; text-shadow:0 0 6px var(--neon),0 0 12px var(--neon-2);}
  }`;
  document.head.appendChild(style);
})();

/* =========== Запуск (показываем старт сообщение и ждём ввода) =========== */
startMessage.style.display = 'block';
</script>
</body>
</html>
/* ========== Встраивание секрета в падающий код (hide-in-matrix) ==========
   Вставь этот блок в конец твоего существующего скрипта.
   Поведение:
   - secretText хранит то, что нужно спрятать (здесь: "1 ноября" закодировано в Base64)
   - startSecretEmit() начинает "вбрасывать" символы секрета по одному в выбранный столбец
   - revealSecret() подсвечивает найденные символы и показывает модал с датой
   - также интегрируется с уже имеющейся пасхалкой (например, combo 110) — при вводе вызовет revealSecret()
====================================================================== */
(function(){
  // --- Настройка секрета (замени "1 ноября" на любую строку, если надо) ---
  const secretEncoded = btoa("1 ноября"); // хранится в кодировке
  const secretText = atob(secretEncoded); // реальный текст показывается по пасхалке

  // куда вбрасывать секрет: выбираем случайный столбец из текущих columns
  // (columns и fontSize определены в основном скрипте; если их нет — можно вычислить)
  let secretColumn = Math.floor(Math.random() * Math.max(1, columns || Math.floor(window.innerWidth / 18)));
  let secretChars = secretText.split('');
  let secretPositions = []; // запомним координаты {x,y,char} для подсветки/модала

  // флаг — идёт ли сейчас вбрасывание
  let secretEmitting = false;

  // Параметры: интервал между вбрасываниями (мс) и яркость/цвет для временного рендера
  const SECRET_EMIT_INTERVAL = 220; // ms между появлением символов секрета
  const SECRET_COLOR = '#fff0ff'; // чуть ярче, но по умолчанию почти сливается
  const SECRET_BRIGHT_COLOR = '#ffffff'; // цвет для подсветки при reveal

  // Функция, которая физически рисует один символ секрета в матрицу
  function placeSecretChar(char){
    // определяем текущую вертикальную позицию drops[secretColumn]
    const col = secretColumn;
    // защититься, если drops или matrixCtx недоступны
    if(typeof drops === 'undefined' || typeof matrixCtx === 'undefined') return;
    // рисуем символ прямо на matrix canvas (однократно)
    const x = col * fontSize;
    const y = drops[col] * fontSize;
    // нарисуем его чуть ярче чтобы в глаз не бросалось сильно (почти сливается)
    matrixCtx.save();
    matrixCtx.fillStyle = SECRET_COLOR;
    matrixCtx.font = `${fontSize}px monospace`;
    matrixCtx.fillText(char, x, y);
    matrixCtx.restore();
    // запомним позицию, чтобы потом подсветить её (примерно)
    secretPositions.push({x: x, y: y, char: char, col: col, row: drops[col]});
    // продвинем "поток" в этом столбце дальше, иначе будет затираться следующим кадром
    drops[col] = drops[col] + 1;
    // если дошли до низа — сбросим верх, чтобы продолжать поток
    if(drops[col] * fontSize > window.innerHeight) drops[col] = 0;
  }

  // Запустить вбрасывание секрета по одному символу (одно за другим)
  function startSecretEmit(){
    if(secretEmitting) return;
    secretEmitting = true;
    let i = 0;
    const timer = setInterval(()=>{
      if(i >= secretChars.length){
        clearInterval(timer);
        secretEmitting = false;
        return;
      }
      placeSecretChar(secretChars[i]);
      i++;
    }, SECRET_EMIT_INTERVAL);
  }

  // Подсветка/ревел: нарисовать яркие прямоугольники/символы в тех позициях и показать модал
  function revealSecret(){
    // краткая вспышка: ярко подсветим все записанные позиции и создадим эффект частиц
    if(secretPositions.length === 0){
      // если ещё не вбрасывали — быстро вбросим всю строчку и подсветим
      startSecretEmit();
      // небольшая задержка, чтобы символы появились
      setTimeout(()=> highlightSecretPositions(true), 500);
    } else {
      highlightSecretPositions(true);
    }
    // покажем модал с датой
    showSecretModal("Пасхалка: " + secretText);
    // и сделаем маленький взрыв частиц в центре экрана
    if(typeof spawnExplosion === 'function'){
      spawnExplosion(window.innerWidth/2, window.innerHeight/3, '#ff69b4', 40);
    }
  }

  // Функция подсветки запомненных позиций
  function highlightSecretPositions(temporary){
    const now = performance.now();
    // нарисуем подсветку на отдельном слое частиц (используем pctx)
    let t = 0;
    const highlightTimer = setInterval(()=>{
      // Clear small region? проще: нарисуем полупрозрачный overlay в тех местах
      // Очищаем particleCanvas прежде чем рисовать
      pctx.clearRect(0,0, pctx.canvas.width, pctx.canvas.height);
      for(let k=0;k<secretPositions.length;k++){
        const s = secretPositions[k];
        // пульсирующий alpha
        const alpha = 0.9 - 0.6*(t/6);
        pctx.globalAlpha = Math.max(0, alpha);
        pctx.fillStyle = SECRET_BRIGHT_COLOR;
        pctx.font = `${fontSize+4}px monospace`;
        pctx.fillText(s.char, s.x, s.y);
      }
      pctx.globalAlpha = 1;
      t++;
      if(t > 6){
        clearInterval(highlightTimer);
        if(temporary) {
          // очистим подсветку через момент
          setTimeout(()=> pctx.clearRect(0,0, pctx.canvas.width, pctx.canvas.height), 120);
        }
      }
    }, 60);
  }

  // Мини-модал для показа секрета
  function showSecretModal(txt){
    const box = document.createElement('div');
    box.style.position = 'fixed';
    box.style.left = '50%';
    box.style.top = '14%';
    box.style.transform = 'translateX(-50%)';
    box.style.padding = '10px 16px';
    box.style.background = 'rgba(255,0,255,0.14)';
    box.style.color = '#ffd6ff';
    box.style.border = '1px solid rgba(255,0,255,0.28)';
    box.style.borderRadius = '8px';
    box.style.fontFamily = 'monospace';
    box.style.zIndex = 99999;
    box.textContent = txt;
    document.body.appendChild(box);
    setTimeout(()=> box.remove(), 5000);
  }

  /* ------------- Интеграция с пасхалкой: клавиши combo (например "110") ------------- */
  // если у тебя уже есть буфер/комбо — можно использовать тот же; иначе добавим локальный слушатель
  const comboLocal = "110";
  let bufferLocal = "";
  window.addEventListener('keydown', (e)=>{
    if(e.key.length === 1){
      bufferLocal += e.key;
      if(bufferLocal.endsWith(comboLocal)){
        // при вводе комбинации — показываем reveal
        revealSecret();
        bufferLocal = "";
      }
      if(bufferLocal.length > 40) bufferLocal = bufferLocal.slice(-40);
    }
  });

  /* ------------- Автоматический запуск эмбеда (опционально) ------------- */
  // ты можешь запускать startSecretEmit() автоматически в начале (заводит секрет в поток),
  // либо запускать его вручную: например startSecretEmit() при старте анимации runAll().
  // Ниже — пример: при старте всей анимации мы запускать embed (чтобы секрет уже выпадал)
  if(typeof startAll === 'function'){
    // если у тебя есть global startAll(), доплнительно запустим эмит через небольшой timeout
    const origStart = startAll;
    window.startAll = function(...a){
      origStart.apply(this,a);
      // старт эмбеда через пару секунд, чтобы он не мешал основной сцене
      setTimeout(()=> startSecretEmit(), 1600);
    };
  } else {
    // иначе — пусть секрет вбрасывается сам через 2.5s пока матрица работает
    setTimeout(()=> startSecretEmit(), 2500);
  }

  // expose for debugging (если нужно)
  window.__secretEmbed = { startSecretEmit, revealSecret, secretText, secretPositions };

})();
